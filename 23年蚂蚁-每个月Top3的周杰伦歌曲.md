**题目来源：** https://www.nowcoder.com/practice/4ab6d198ea8447fe9b6a1cad1f671503?tpId=375&tqId=10737572&sourceUrl=%2Fexam%2Foj  
**做题日期：** 2025年12月1日

## 问题背景与目标
- 分析目标：统计 2022 年中，年龄在 18 到 25 岁用户中，按月份统计周杰伦歌曲的播放量（play_pv），并返回每个月播放量排名前 3 的歌曲。
- 输入表：
play_log：记录播放事件，包含 fdate（播放时间）、song_id、user_id 等字段。
song_info：歌曲元数据，包含 song_id、song_name、singer_name 等字段。
user_info：用户信息，包含 user_id、age 等字段。

## 最终 SQL
```sql
with base as(
    select month(p.fdate) as month,
    s.song_name,
    s.song_id,
    count(*) as play_pv
    from play_log p
    join song_info s on p.song_id = s.song_id
    join user_info u on p.user_id = u.user_id
    where year(p.fdate) = 2022
        and s.singer_name = '周杰伦'
        and u.age between 18 and 25
    group by month(p.fdate),s.song_name,s.song_id
)

select *
from (
    select month,
    row_number() over (partition by month order by play_pv desc,song_id) as ranking,
    song_name,play_pv
    from base
) t
where ranking <= 3
order by month,ranking;
```

## 解题思路
1. **锁定时间与用户范围**  
   - 过滤播放记录时间为 2022 年：`YEAR(p.fdate) = 2022`  
   - 限定用户年龄在 18 到 25 岁之间：`u.age BETWEEN 18 AND 25`  
   - 这样可以减少后续处理的数据量。

2. **关联三张表**  
   - `play_log` JOIN `song_info`：通过 `song_id` 获取歌曲元数据，如 `song_name`、`singer_name`。  
   - `play_log` JOIN `user_info`：通过 `user_id` 限定用户年龄范围。

3. **按月和歌曲聚合播放量**  
   - 按 `MONTH(p.fdate)`、`s.song_id`、`s.song_name` 做 `GROUP BY`。  
   - 计算播放量：`COUNT(*) AS play_pv`。  
   - **注意：必须把 `s.song_name` 放入 `GROUP BY` 或使用聚合函数/`ANY_VALUE`，以兼容 `ONLY_FULL_GROUP_BY` 模式。**

4. **按月做 Top-N（窗口函数）**  
   - 使用 `ROW_NUMBER() OVER (PARTITION BY month ORDER BY play_pv DESC, song_id)` 给每个月的歌曲按播放量排名。  
   - 筛选 `ranking <= 3`，得到每个月播放量最高的前三首歌。

5. **结果排序**  
   - 最终按 `month` 和 `ranking` 排序，便于阅读或导出报表。
  
## 为什么要分两层（先聚合再窗口）？
1. 语义清晰：聚合计算（`COUNT`）先得到每首歌每月的播放量；窗口函数再根据这个值做排名。
2. 兼容性强：避免将 `COUNT()` 与窗口函数混写在同一层，解决 `ONLY_FULL_GROUP_BY` 报错与潜在语义歧义。
3. 可读性与维护性：更利于调试和扩展（例如增加更多维度或筛选条件）。

