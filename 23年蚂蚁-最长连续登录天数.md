**题目来源：** https://www.nowcoder.com/practice/cb8bc687046e4d32ad38de62c48ad79b?tpId=375&tqId=10737573&sourceUrl=%2Fexam%2Foj  
**做题时间：** 2025年12月2日

# 问题背景与目标
我们需要在指定时间范围内（2023-01-01 至 2023-01-31），统计每个用户的最长连续活跃天数。  
所谓“连续活跃”，指用户在相邻的自然日都出现记录。最终结果是输出每个用户的最大连续活跃天数。

# 最终 SQL
```sql
with order_logs as(
    select 
        user_id,
        fdate,
        row_number() over (partition by user_id order by fdate) as rn
    from tb_dau
    where fdate between '2023-01-01' and '2023-01-31'
),
group_logs as(
    select
        user_id,
        rn,
        date_sub(fdate, interval rn day) as grp
    from order_logs
)
select 
    user_id,
    max(consec_days) as max_consec_days
from(
    select
        user_id,
        grp,
        count(*) as consec_days
    from group_logs
    group by user_id,grp
) t
group by user_id;
```


# 解题思路
1. 获取用户在日期范围内的活跃记录，并按日期排序。  
   使用 `row_number()` 为每个用户的每一天活跃记录编号，为后续识别连续天数做准备。

2. 通过 “日期 - 行号” 技巧识别连续分组（Gap and Island）。  
   计算 `grp = fdate - rn`：  
   - 如果用户的活跃日期是连续的，则 `fdate - rn` 会得到相同的值  
   - 若中间有断开，计算结果会变化，代表新一段连续记录的开始

3. 按分组统计每段连续活跃天数。  
   对同一用户、同一 grp 的记录进行 `count(*)`，得到每一段连续活跃的长度。

4. 对每个用户取最长连续活跃天数。  
   使用 `max(consec_days)` 得到最终答案。

# 相关语法知识点 
1. 窗口函数 row_number()
- 用于为分组内的数据按指定排序生成递增序号  
- 格式：`row_number() over(partition by x order by y)`

2. Gap and Island 问题处理方法
- 常用技巧：“日期 - 连续编号”  
- 连续的日期区间（Island）会得到相同的 `(date - rn)` 结果  
- 不连续则会产生新的分组（Gap）

3. date_sub 函数
- 用于对日期做加减操作  
- 格式：`date_sub(date, interval n day)`

4. 分组聚合
- 使用 `group by` 对用户和 grp 分组，统计连续天数  
- 最终对每个用户求最大连续天数 `max()`
